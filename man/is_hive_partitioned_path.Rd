% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils-hive-partitions.R
\name{is_hive_partitioned_path}
\alias{is_hive_partitioned_path}
\title{Check whether a path contains Hive-style partitioning}
\usage{
is_hive_partitioned_path(path, strict = TRUE)
}
\arguments{
\item{path}{Character string. Path to a
file or directory.}

\item{strict}{Logical. If \code{TRUE}, the function will throw an error
if any malformed partition segments are found (e.g., \verb{=value},
missing key, or malformed \code{=} without a value). If \code{FALSE}, it simply returns
\code{TRUE} if any valid \code{key=value} segments are found.}
}
\value{
A logical value: \code{TRUE} if the path contains one or more valid Hive-style
partition segments, \code{FALSE} otherwise.
}
\description{
This function checks if a given file or directory path includes one or more
Hive-style partition segments (i.e., subdirectories formatted as \code{key=value}).
This function can operate in a strict or lenient mode, depending on whether
you want to catch malformed partition-like segments.
}
\details{
A valid partition segment must:
\itemize{
\item Contain an equals sign (\code{=})
\item Have a non-empty key before the equals sign
\item May have an empty value (interpreted as \code{NA} in most Hive/Arrow contexts)
}

In strict mode, the function validates that all \code{key=value} segments are well-formed
and will abort if any are not.
}
\examples{
is_hive_partitioned_path("data/country=US/year=2024/file.parquet")
is_hive_partitioned_path("data/country=/year=2024/", strict = TRUE)
# is_hive_partitioned_path("data/=US/year=2024/", strict = TRUE) # This will error

}
\seealso{
\code{\link[=extract_hive_partitions]{extract_hive_partitions()}} to extract key-value pairs from Hive-style paths.
}
